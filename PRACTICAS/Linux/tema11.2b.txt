## TEMA 11 - Replicacion a servidor "Hot Standby"
## 11.2.- Opcion 1, replicacion asincrona de archivos WAL

## Desde un terminal SSH
## se vuelve a levantar la INSTANCIA1
export PGPORT=5432
export PGDATA=$HOME/curso/I1
pg_ctl start -D $PGDATA



## abrir otro terminal SSH
## la INSTANCIA 2 usa otro puerto (por estar en la misma maquina)
export PGPORT=5400
export PGDATA=$HOME/curso/I2


##################################################
## Restauramos en otro directorio la copia de seguridad del Tema9, 
## la copia base hecha con pg_start/stop_backup y con el modo archivado habilitado
pg_ctl stop
pg_ctl status
cd
ls $PGDATA
rm -rf $PGDATA/*
rm -rf $HOME/curso/wal/I2/*
chmod 0700 $PGDATA
cp -a $HOME/curso/backups/base_I1/* $PGDATA
## ¡¡¡ Al borrar el contenido de $PGDATA/pg_wal de la restauracion, SE NECESITARA la información de "backup_label" !!!
rm $PGDATA/pg_wal/*
rm $PGDATA/pg_wal/archive_status/*
## Se recuperan los WAL generados durante la copia de seguridad
## y se dejan en donde los guarda el Servidor Principal (I1, $HOME/curso/wal/I1)
ls -lhrt $PGDATA/wal_generados
ls -lhrt $HOME/curso/wal/I1
chmod 0400 $HOME/curso/wal/I1/*
cp -a $PGDATA/wal_generados/* $HOME/curso/wal/I1
chmod 0600 $HOME/curso/wal/I1/*

vi $PGDATA/postgresql.conf
 port = 5400
 hot_standby = on  #ya es la option por defecto
## FIN Pasos Recuperación



##################################################
## Se arranca el Servidor Secundario
echo "standby_mode = 'on'" > $PGDATA/recovery.conf
echo "restore_command = 'cp /home/postgres/curso/wal/I1/%f %p'" >> $PGDATA/recovery.conf
echo "trigger_file = '/home/postgres/curso/I2/fin_replica.txt'" >> $PGDATA/recovery.conf
cat $PGDATA/recovery.conf

rm $PGDATA/log/*
pg_ctl start -D $PGDATA

## no hay recovery.done
ls $PGDATA/recovery*
ls -lrt $PGDATA/pg_wal
ls -lrt $PGDATA/pg_wal/archive_status
## se comprueba el log: less $PGDATA/log/postgresql-2019-

## se comprueban que estan los datos hasta que se apago I1
psql bd_pruebas4
 SELECT pg_is_in_recovery();
 \l
 \dt
 SELECT * FROM tpitr3;
 \q
tail -200f $PGDATA/log/postgresql-2019-


## en el terminal con la INSTANCIA1
psql
 \c bd_pruebas4
 \dt
 INSERT INTO tpitr3 VALUES (6, 'seis');
 SELECT * FROM tpitr3;
 CREATE TABLE treplica1 (
        id integer,
        nombre varchar(10)
 );
 INSERT INTO treplica1 VALUES (1, 'Uno');
 INSERT INTO treplica1 VALUES (2, 'Dos');
 SELECT * FROM treplica1;

 --forzamos a almacenar archivos WAL 
 SELECT pg_switch_wal();
 SELECT pg_current_wal_lsn();
 SELECT pg_walfile_name(pg_current_wal_lsn());
 \! ls -lrt $PGDATA/pg_wal
 \! ls -lrt $PGDATA/pg_wal/archive_status
 \! ls -lrt /home/postgres/curso/wal/I1

## en el terminal con la INSTANCIA2
## se comprueban los mensajes del comando tail
## vemos que ha leido el ultimo WAL almacenado por INSTANCIA1
## se pone fin al modo de Replicacion (tambien se puede usar el comando "pg_ctl promote")
touch /home/postgres/curso/I2/fin_replica.txt
ls $PGDATA/recovery*
## se comprueba el log: less $PGDATA/log/postgresql-2019-


## en el terminal con la INSTANCIA1
## se inserta un nuevo dato que no debe aparecer en la replica
psql
 INSERT INTO treplica1 VALUES (3, 'Tres');
 SELECT * FROM treplica1;
 SELECT pg_switch_wal();
 \q
pg_ctl stop


## en el terminal con la INSTANCIA2
## se comprueban que estan los datos hasta que se detuvo la replicacion
psql bd_pruebas4
 SELECT pg_is_in_recovery();
 \l
 \dt
 SELECT * FROM tpitr3;
 SELECT * FROM treplica1;
 \c bd_pruebas1 app_prueba
 \dt
 SELECT * FROM test1;
 INSERT INTO test1 VALUES (11, 'fin repli');
 SELECT * FROM test1;
\q
pg_ctl stop
